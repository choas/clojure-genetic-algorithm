; Copyright 2009 yogthos; Lars Gregori
;
; Licensed under the Apache License, Version 2.0 (the "License"); you may
; not use this file except in compliance with the License. You may obtain
; a copy of the License at
;
; http://www.apache.org/licenses/LICENSE-2.0
;
; Unless required by applicable law or agreed to in writing, software
; distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
; WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
; License for the specific language governing permissions and limitations
; under the License.

(ns ga.main (:gen-class ))

(defstruct mutator-struct :func :args)
(defstruct member :fitness :value)

;helper functions
(defn zip 
  "helper function which pairs values in two lists xs ys" 
  [xs ys]
  (loop [pairs (transient []) l1 xs l2 ys]
    (if (or (empty? l1) (empty? l2))
      (persistent! pairs)
      (recur (conj! pairs [(first l1) (first l2)]) (rest l1) (rest l2)))))
      
(defn rand-in-range 
  "generates a random value within the given range"
  [min max]
  (int (+ (* (Math/random) (inc (- max min))) min)))

;functions for evolving members
(defn- gen-member [mutator]
    (struct member nil ((:func mutator) (:args mutator))))
  
(defn- mutate 
  "randomly mutates values in members of the population using the mutator function"
  [population mutator threshold]  
  (doseq [member population]                    
      (let [old-member (:value @member)
            gen-member (gen-member mutator)
            new-member (map #(if (< (rand) threshold) (first %1) (second %1)) (zip (:value gen-member) old-member))]
      (swap! member #(assoc %1 :value new-member)))))

(defn- rank 
  "ranks the members of the population using the val-comp function and the target value"
  [population val-comp]
  (doseq [member population]
    (swap! member #(assoc %1 :fitness (val-comp (:value %1)))))
  (reverse (sort #(compare (:fitness @%1) (:fitness @%2)) population)))

(defn- fit? 
  "checks if population (ranked by fitness) has a member which match the desired value"
  [population]
  (== 0 (:fitness @(first population))))

(defn- mate 
  "cross-breeds existing members to produce offspring
  values are generated by randomly  combining first and second 
  halves of members of the population."
  [population]
  (let [halves (split-at (/ (count population) 2) population)]
    (loop [new-members (transient []) m1 (first halves) m2 (second halves)]   
       (if (or (empty? m1) (empty? m2))
         (persistent! new-members)
         (let [values (if (> (rand) 0.5) 
                        [(:value @(first m1)) (:value @(first m2))]
                        [(:value @(first m2)) (:value @(first m1))])
               val (concat (take (/ (count (first values)) 2) (first values)) 
                           (drop (/ (count (second values)) 2) (second values)))]
           (recur (conj! new-members (atom (struct member nil val)))
                  (rest m1) (rest m2)))))))
                    
(defn- evolve-step 
  "mutates the populationtakes then combines the top members 
   of the population with some of the bottom members to promote 
   genetic diversity, and adds some offspring"
  [population mutator threshold]                 
  (mutate population mutator threshold)
  (let [promote-size (/ (count population) 5)
        keep-size    (- (/ (count population) 2) promote-size)
        parts (split-at keep-size population)]      
      (concat (first parts)
              (take promote-size (second parts))
              (mate population))))

(defn- init-population 
  "creates a population using the generator function"
  [size mutator]
  (for [i (range 0 size)] (atom (gen-member mutator))))

(defn evolve 
   "generates the initial population and ranks it, then runs the evolve-step until 
    the solution is found"
   [size threshold mutator comp]   
  (loop [population (init-population size mutator)]
    (let [ranked (rank population comp)]
      (if (fit? ranked)
        ranked
        (recur (evolve-step ranked mutator threshold))))))
